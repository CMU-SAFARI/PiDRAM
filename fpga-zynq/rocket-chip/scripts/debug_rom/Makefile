# See LICENSE.SiFive for license details
# Recursive make is bad, but in this case we're cross compiling which is a
# pretty unusual use case.

CC = $(RISCV)/bin/riscv64-unknown-elf-gcc
OBJCOPY = $(RISCV)/bin/riscv64-unknown-elf-objcopy

COMPILE = $(CC) -nostdlib -nostartfiles -I$(RISCV)/include/ -Tlink.ld

ELFS = debug_rom
DEPS = debug_rom.S link.ld

all: $(patsubst %,%.h,$(ELFS))

publish: debug_rom.scala
	mv $< ../../src/main/scala/uncore/devices/debug/DebugRomContents.scala

%.scala: %.raw
	xxd -i $^ | sed -e "s/^unsigned char debug_rom_raw\[\] = {/\/\/ This file was auto-generated by 'make publish' in debug\/ directory.\n\npackage uncore.devices\n\nobject DebugRomContents {\n\n  def apply() : Array[Byte] = { Array (/" \
	-e  "s/};/  ).map(_.toByte) }\n\n}/" \
	-e  "s/^unsigned int debug_rom_raw_len.*//"  > $@


%.raw:	%
	$(OBJCOPY) -O binary --only-section .text $^ $@

debug_rom:	$(DEPS)
	$(COMPILE) -o $@ $^

clean:
	rm -f $(ELFS) debug_rom*.raw debug_rom*.h
