/* autogenerated - do not edit */
#include <jim.h>
int Jim_nshelperInit(Jim_Interp *interp)
{
	if (Jim_PackageProvide(interp, "nshelper", "1.0", JIM_ERRMSG)) return JIM_ERR;
	return Jim_EvalSource(interp, "nshelper.tcl", 1, "\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"proc {namespace delete} {args} {\n"
"	foreach name $args {\n"
"		if {$name ni {:: \"\"}} {\n"
"			set name [uplevel 1 [list ::namespace canon $name]]\n"
"			foreach i [info commands ${name}::*] { rename $i \"\" }\n"
"			uplevel #0 [list unset {*}[info globals ${name}::*]]\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"proc {namespace origin} {name} {\n"
"	set nscanon [uplevel 1 [list ::namespace canon $name]]\n"
"	if {[exists -alias $nscanon]} {\n"
"		tailcall {namespace origin} [info alias $nscanon]\n"
"	}\n"
"	if {[exists -command $nscanon]} {\n"
"		return ::$nscanon\n"
"	}\n"
"	if {[exists -command $name]} {\n"
"		return ::$name\n"
"	}\n"
"\n"
"	return -code error \"invalid command name \\\"$name\\\"\"\n"
"}\n"
"\n"
"proc {namespace which} {{type -command} name} {\n"
"	set nsname ::[uplevel 1 [list ::namespace canon $name]]\n"
"	if {$type eq \"-variable\"} {\n"
"		return $nsname\n"
"	}\n"
"	if {$type eq \"-command\"} {\n"
"		if {[exists -command $nsname]} {\n"
"			return $nsname\n"
"		} elseif {[exists -command ::$name]} {\n"
"			return ::$name\n"
"		}\n"
"		return \"\"\n"
"	}\n"
"	return -code error {wrong # args: should be \"namespace which ?-command? ?-variable? name\"}\n"
"}\n"
"\n"
"\n"
"proc {namespace code} {arg} {\n"
"	if {[string first \"::namespace inscope \" $arg] == 0} {\n"
"\n"
"		return $arg\n"
"	}\n"
"	list ::namespace inscope [uplevel 1 ::namespace current] $arg\n"
"}\n"
"\n"
"proc {namespace inscope} {name arg args} {\n"
"	tailcall namespace eval $name $arg $args\n"
"}\n"
"\n"
"proc {namespace import} {args} {\n"
"	set current [uplevel 1 ::namespace canon]\n"
"\n"
"	foreach pattern $args {\n"
"		foreach cmd [info commands [namespace canon $current $pattern]] {\n"
"			if {[namespace qualifiers $cmd] eq $current} {\n"
"				return -code error \"import pattern \\\"$pattern\\\" tries to import from namespace \\\"$current\\\" into itself\"\n"
"			}\n"
"\n"
"\n"
"			set newcmd ${current}::[namespace tail $cmd]\n"
"\n"
"			set alias $cmd\n"
"			while {[exists -alias $alias]} {\n"
"				set alias [info alias $alias]\n"
"				if {$alias eq $newcmd} {\n"
"					return -code error \"import pattern \\\"$pattern\\\" would create a loop\"\n"
"				}\n"
"			}\n"
"\n"
"			alias $newcmd $cmd\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"\n"
"proc {namespace info} {cmd {pattern *}} {\n"
"	set current [uplevel 1 ::namespace canon]\n"
"\n"
"	if {[string first :: $pattern] == 0} {\n"
"		set global 1\n"
"		set prefix ::\n"
"	} else {\n"
"		set global 0\n"
"		set clen [string length $current]\n"
"		incr clen 2\n"
"	}\n"
"	set fqp [namespace canon $current $pattern]\n"
"	switch -glob -- $cmd {\n"
"		co* - p* {\n"
"			if {$global} {\n"
"				set result [info $cmd $fqp]\n"
"			} else {\n"
"\n"
"				set r {}\n"
"				foreach c [info $cmd $fqp] {\n"
"					dict set r [string range $c $clen end] 1\n"
"				}\n"
"				if {[string match co* $cmd]} {\n"
"\n"
"					foreach c [info -nons commands $pattern] {\n"
"						dict set r $c 1\n"
"					}\n"
"				}\n"
"				set result [dict keys $r]\n"
"			}\n"
"		}\n"
"		ch* {\n"
"			set result [info channels $pattern]\n"
"		}\n"
"		v* {\n"
"\n"
"			set result [uplevel #0 info -nons vars $fqp]\n"
"		}\n"
"		g* {\n"
"			set result [info globals $fqp]\n"
"		}\n"
"		l* {\n"
"			set result [uplevel 1 info -nons locals $pattern]\n"
"		}\n"
"	}\n"
"	if {$global} {\n"
"		set result [lmap p $result { string cat $prefix $p }]\n"
"	}\n"
"	return $result\n"
"}\n"
"\n"
"proc {namespace upvar} {ns args} {\n"
"	set nscanon ::[uplevel 1 [list ::namespace canon $ns]]\n"
"	set script [list upvar 0]\n"
"	foreach {other local} $args {\n"
"		lappend script ${nscanon}::$other $local\n"
"	}\n"
"	tailcall {*}$script\n"
"}\n");
}
